package route

import (
	"net/http"

	"github.com/evergreen-ci/evergreen/apiv3"
	"github.com/evergreen-ci/evergreen/apiv3/model"
	"github.com/evergreen-ci/evergreen/apiv3/servicecontext"
	"github.com/evergreen-ci/evergreen/util"
)

const (
	JsonMimeType = "application/json; charset=utf-8"
)

// MethodHandler contains all of the methods necessary for completely processing
// an API request. It contains an Authenticator to control access to the method
// and a RequestHandler to perform the required work for the request.
type MethodHandler struct {
	// MethodType is the HTTP Method Type that this handler will handler.
	// POST, PUT, DELETE, etc.
	MethodType string

	Authenticator
	RequestHandler
}

// ResponseData holds the information that the handler function will need to form
// its encoded response. A ResponseData is generated by a RequestHandler's Execute
// function and parsed in the main handler method.
type ResponseData struct {
	// Result is the resulting API models that the API request needs to return
	// to the user, either because they were queried for or because they were
	// created by this request.
	Result []model.Model

	// Metadata is an interface that holds any additional data that the handler
	// will need for encoding the API response.
	Metadata interface{}
}

// RequestHandler is an interface that defines how to process an HTTP request
// against an API resource.
type RequestHandler interface {
	// Handler defines how to fetch a new version of this handler.
	Handler() RequestHandler

	// Parse defines how to retrieve the needed parameters from the HTTP request.
	// All needed data should be retrieved during the parse function since
	// other functions do not have access to the HTTP request.
	Parse(*http.Request) error

	// Validate defines how to ensure all needed data is present and in the format
	// expected by the route
	Validate() error

	// Execute performs the necessary work on the evergreen backend and returns
	// an API model to be surfaced to the user.
	Execute(servicecontext.ServiceContext) (ResponseData, error)
}

// makeHandler makes an http.HandlerFunc that wraps calls to each of the api
// Method functions. It marshalls the response to JSON and writes it out to
// as the response. If any of the functions return an error, it handles creating
// a JSON error and sending it as the response. The 'route' is the path that is
// used to access this API endpoint and 'version' is the version number of the API
// that this method is used for.
func makeHandler(methodHandler MethodHandler, sc servicecontext.ServiceContext,
	route string, version int) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", JsonMimeType)

		if err := methodHandler.Authenticate(sc, r); err != nil {
			handleAPIError(err, w)
			return
		}

		reqHandler := methodHandler.RequestHandler.Handler()

		if err := reqHandler.Parse(r); err != nil {
			handleAPIError(err, w)
			return
		}
		if err := reqHandler.Validate(); err != nil {
			handleAPIError(err, w)
			return
		}
		result, err := reqHandler.Execute(sc)
		if err != nil {
			handleAPIError(err, w)
			return
		}

		// Check the type of the results metadata. If it is a PaginationMetadata,
		// create the pagination headers. Otherwise, no additional processing is needed.
		// NOTE: This could expand to include additional metadata types that define
		// other specific cases for how to handle results.
		switch m := result.Metadata.(type) {
		case *PaginationMetadata:
			err := m.MakeHeader(w, sc.GetPrefix(), sc.GetURL(), route, version)
			if err != nil {
				handleAPIError(err, w)
				return
			}
			util.WriteJSON(&w, result.Result, http.StatusOK)
		default:
			if len(result.Result) < 1 {
				http.Error(w, "{}", http.StatusInternalServerError)
				return
			}
			util.WriteJSON(&w, result.Result[0], http.StatusOK)
		}
	}
}

// handleAPIError handles writing the given error to the response writer.
// It checks if the given error is an APIError and turns it into JSON to be
// written back to the requester. If the error is unknown, it must have come
// from a service layer package, in which case it is an internal server error
// and is returned as such.
func handleAPIError(e error, w http.ResponseWriter) {
	apiErr := apiv3.APIError{}

	apiErr.StatusCode = http.StatusInternalServerError
	apiErr.Message = e.Error()

	if castError, ok := e.(apiv3.APIError); ok {
		apiErr = castError
	}

	util.WriteJSON(&w, apiErr, apiErr.StatusCode)
}
